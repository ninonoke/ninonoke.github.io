{"version":3,"sources":["../../src/support/unsupported-environment.ts","../../src/support/supports-scroll-behavior.ts","../../node_modules/tslib/tslib.es6.js","../../src/util/scrolling-element.ts","../../src/util/attribute.ts","../../src/util/get-scroll-behavior.ts","../../src/util/easing.ts","../../src/util/disable-scroll-snap.ts","../../src/smooth-scroll/smooth-scroll/smooth-scroll.ts","../../src/original/element/scroll.ts","../../src/original/window/scroll.ts","../../src/original/element/scroll-by.ts","../../src/original/window/scroll-by.ts","../../src/original/element/scroll-to.ts","../../src/original/window/scroll-to.ts","../../src/scroll-method/get-original-scroll-method-for-kind.ts","../../src/smooth-scroll/get-smooth-scroll-options/get-smooth-scroll-options.ts","../../src/util/now.ts","../../src/util/ensure-numeric.ts","../../src/util/is-scroll-to-options.ts","../../src/patch/shared.ts","../../src/util/get-parent.ts","../../src/util/find-nearest-ancestor-with-scroll-behavior.ts","../../src/util/get-location-origin.ts","../../src/patch/anchor/catch-navigation.ts","../../src/util/find-nearest-root.ts","../../src/original/element/scroll-into-view.ts","../../src/patch/element/compute-scroll-into-view.ts","../../src/patch/element/scroll-into-view.ts","../../src/original/element/scroll-top.ts","../../src/patch/element/scroll-top.ts","../../src/original/element/scroll-left.ts","../../src/support/supports-element-prototype-scroll-methods.ts","../../src/index.ts","../../src/patch/element/scroll.ts","../../src/patch/element/scroll-by.ts","../../src/patch/element/scroll-to.ts","../../src/patch/element/scroll-left.ts","../../src/patch/window/scroll.ts","../../src/patch/window/scroll-by.ts","../../src/patch/window/scroll-to.ts","../../src/patch/patch.ts"],"names":["UNSUPPORTED_ENVIRONMENT","window","SUPPORTS_SCROLL_BEHAVIOR","document","documentElement","style","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","getScrollingElement","scrollingElement","STYLE_ATTRIBUTE_PROPERTY_REGEXP","RegExp","STYLE_ATTRIBUTE_PROPERTY_NAME","appendScrollBehaviorToStyleAttribute","element","behavior","addition","attributeValue","getAttribute","existingValueForProperty","parseScrollBehaviorFromStyleAttribute","replacementProperty","replace","setAttribute","endsWith","styleAttributeValue","includes","match","getScrollBehavior","inputTarget","options","target","scrollBehaviorPropertyValue","computedStyleValue","getComputedStyle","getPropertyValue","ease","k","Math","cos","PI","NOOP","reset","map","WeakMap","undefined","smoothScroll","startTime","startX","startY","endX","endY","method","scroller","timeLapsed","distanceX","distanceY","speed","max","abs","scrollSnapFix","cachedScrollSnapValue","cachedScrollBehaviorStyleAttributeValue","secondaryScroller","secondaryScrollerCachedScrollSnapValue","secondaryScrollerCachedScrollBehaviorStyleAttributeValue","existingResult","get","release","scrollSnapType","body","cachedComputedScrollSnapValue","secondaryScrollerCachedComputedScrollSnapValue","hasReleased","eventTarget","removeEventListener","resetHandler","set","setTimeout","addEventListener","disableScrollSnap","requestAnimationFrame","animate","timestamp","percentage","min","positionX","floor","positionY","ELEMENT_ORIGINAL_SCROLL","Element","scroll","WINDOW_ORIGINAL_SCROLL","ELEMENT_ORIGINAL_SCROLL_BY","scrollBy","WINDOW_ORIGINAL_SCROLL_BY","ELEMENT_ORIGINAL_SCROLL_TO","scrollTo","WINDOW_ORIGINAL_SCROLL_TO","elementPrototypeScrollFallback","x","y","__adjustingScrollPosition","scrollLeft","scrollTop","elementPrototypeScrollToFallback","elementPrototypeScrollByFallback","getOriginalScrollMethodForKind","kind","getSmoothScrollOptions","performance","now","Date","bind","scrollX","pageXOffset","scrollY","pageYOffset","ensureNumeric","parseFloat","isScrollToOptions","handleScrollMethod","optionsOrX","left","top","onScrollWithOptions","TypeError","normalizeScrollCoordinates","getScrollToOptionsWithValidation","getParent","currentElement","nodeType","parentNode","ShadowRoot","host","Node","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","findNearestAncestorsWithScrollBehavior","getLocationOrigin","locationLike","location","origin","port","protocol","hostname","ID_WITH_LEADING_DIGIT_REGEXP","catchNavigation","isTrusted","HTMLAnchorElement","pathname","search","hash","root","findNearestRoot","elementMatch","getElementById","slice","querySelector","preventDefault","scrollIntoView","ELEMENT_ORIGINAL_SCROLL_INTO_VIEW","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","computeScrollIntoView","block","inline","viewportWidth","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","viewportX","viewportY","right","bottom","targetBlock","targetTop","targetBottom","targetHeight","targetInline","targetLeft","targetWidth","targetRight","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR","getOwnPropertyDescriptor","ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR","SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS","arg","normalizedOptions","ancestorWithScroll","ancestorWithScrollBehavior","HTMLElement","defineProperty"],"mappings":"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","file":"static/js/3.230d3a82.chunk.js","sourcesContent":["export const UNSUPPORTED_ENVIRONMENT = typeof window === \"undefined\";\n","import {UNSUPPORTED_ENVIRONMENT} from \"./unsupported-environment\";\n\n/**\n * Is true if the browser natively supports the 'scroll-behavior' CSS-property.\n * @type {boolean}\n */\nexport const SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : \"scrollBehavior\" in document.documentElement.style;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export function getScrollingElement(): HTMLElement {\n\tif (document.scrollingElement != null) {\n\t\treturn document.scrollingElement as HTMLElement;\n\t} else {\n\t\treturn document.documentElement;\n\t}\n}\n","const STYLE_ATTRIBUTE_PROPERTY_NAME = \"scroll-behavior\";\nconst STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(`${STYLE_ATTRIBUTE_PROPERTY_NAME}:\\\\s*([^;]*)`);\n\n/**\n * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.\n * If it doesnt already have one, it will add it.\n * @param {Element} element\n * @param {ScrollBehavior} behavior\n */\nexport function appendScrollBehaviorToStyleAttribute(element: Element, behavior: ScrollBehavior): void {\n\tconst addition = `${STYLE_ATTRIBUTE_PROPERTY_NAME}:${behavior}`;\n\tlet attributeValue = element.getAttribute(\"style\");\n\tif (attributeValue == null || attributeValue === \"\") {\n\t\telement.setAttribute(\"style\", addition);\n\t\treturn;\n\t}\n\n\t// The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced\n\tconst existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);\n\tif (existingValueForProperty != null) {\n\t\tconst replacementProperty = `${STYLE_ATTRIBUTE_PROPERTY_NAME}:${existingValueForProperty}`;\n\t\t// Replace the variant that ends with a semi-colon which it may\n\t\tattributeValue = attributeValue.replace(`${replacementProperty};`, \"\");\n\t\t// Replace the variant that *doesn't* end with a semi-colon\n\t\tattributeValue = attributeValue.replace(replacementProperty, \"\");\n\t}\n\n\t// Now, append the behavior to the string.\n\telement.setAttribute(\"style\", attributeValue.endsWith(\";\") ? `${attributeValue}${addition}` : `;${attributeValue}${addition}`);\n}\n\n/**\n * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract\n * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)\n * @param {Element} element\n * @returns {ScrollBehavior?}\n */\nexport function parseScrollBehaviorFromStyleAttribute(element: Element): ScrollBehavior | undefined {\n\tconst styleAttributeValue = element.getAttribute(\"style\");\n\tif (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {\n\t\tconst match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);\n\t\tif (match != null) {\n\t\t\tconst [, behavior] = match;\n\t\t\tif (behavior != null && behavior !== \"\") {\n\t\t\t\treturn behavior as ScrollBehavior;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n","import {getScrollingElement} from \"./scrolling-element\";\nimport {parseScrollBehaviorFromStyleAttribute} from \"./attribute\";\n\nconst styleDeclarationPropertyName = \"scrollBehavior\" as keyof CSSStyleDeclaration;\nexport type ScrollBehaviorRawValue = ScrollBehavior | null | \"\";\n\n/**\n * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element\n * within the DOM\n * @param {Element|HTMLElement|Window} inputTarget\n * @param {ScrollOptions} [options]\n * @returns {ScrollBehavior}\n */\nexport function getScrollBehavior(inputTarget: Element | HTMLElement | Window, options?: ScrollOptions): ScrollBehavior | undefined {\n\t// If the given 'behavior' is 'smooth', apply smooth scrolling no matter what\n\tif (options != null && options.behavior === \"smooth\") return \"smooth\";\n\n\tconst target: HTMLElement = \"style\" in inputTarget ? inputTarget : getScrollingElement();\n\n\tlet value: ScrollBehavior | undefined;\n\n\tif (\"style\" in target) {\n\t\t// Check if scroll-behavior is set as a property on the CSSStyleDeclaration\n\t\tconst scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName] as ScrollBehaviorRawValue;\n\t\t// Return it if it is given and has a proper value\n\t\tif (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== \"\") {\n\t\t\tvalue = scrollBehaviorPropertyValue;\n\t\t}\n\t}\n\n\tif (value == null) {\n\t\tconst attributeValue = target.getAttribute(\"scroll-behavior\");\n\t\tif (attributeValue != null && attributeValue !== \"\") {\n\t\t\tvalue = attributeValue as ScrollBehavior;\n\t\t}\n\t}\n\n\tif (value == null) {\n\t\t// Otherwise, check if it is set as an inline style\n\t\tvalue = parseScrollBehaviorFromStyleAttribute(target);\n\t}\n\n\tif (value == null) {\n\t\t// Take the computed style for the element and see if it contains a specific 'scroll-behavior' value\n\t\tconst computedStyle = getComputedStyle(target);\n\t\tconst computedStyleValue = computedStyle.getPropertyValue(\"scrollBehavior\") as ScrollBehaviorRawValue;\n\t\tif (computedStyleValue != null && computedStyleValue !== \"\") {\n\t\t\tvalue = computedStyleValue;\n\t\t}\n\t}\n\n\t// In all other cases, use the value from the CSSOM\n\treturn value;\n}\n","const HALF = 0.5;\n\n/**\n * The easing function to use when applying the smooth scrolling\n * @param {number} k\n * @returns {number}\n */\nexport function ease(k: number) {\n\treturn HALF * (1 - Math.cos(Math.PI * k));\n}\n","import {ScrollSnappable} from \"./scroll-snappable\";\nimport {SUPPORTS_SCROLL_BEHAVIOR} from \"../support/supports-scroll-behavior\";\nimport {appendScrollBehaviorToStyleAttribute, parseScrollBehaviorFromStyleAttribute} from \"./attribute\";\nimport {getScrollingElement} from \"./scrolling-element\";\n\nexport interface DisableScrollSnapResult {\n\treset(): void;\n}\n\nexport interface DisableScrollSnapReleaser {\n\tcachedScrollSnapValue: string | null;\n\tcachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\tsecondaryScroller: ScrollSnappable | undefined;\n\tsecondaryScrollerCachedScrollSnapValue: string | null | undefined;\n\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\trelease(): void;\n}\n\nconst NOOP: DisableScrollSnapResult = {\n\treset: () => {}\n};\n\nconst map = typeof WeakMap === \"undefined\" ? undefined : new WeakMap<ScrollSnappable, DisableScrollSnapReleaser>();\n\nexport function disableScrollSnap(scroller: ScrollSnappable): DisableScrollSnapResult {\n\t// If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix\n\tif (SUPPORTS_SCROLL_BEHAVIOR || map == null) {\n\t\treturn NOOP;\n\t}\n\n\tconst scrollingElement = getScrollingElement();\n\n\tlet cachedScrollSnapValue: string | null;\n\tlet cachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\tlet secondaryScroller: ScrollSnappable | undefined;\n\tlet secondaryScrollerCachedScrollSnapValue: string | null | undefined;\n\tlet secondaryScrollerCachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\tconst existingResult = map.get(scroller);\n\tif (existingResult != null) {\n\t\tcachedScrollSnapValue = existingResult.cachedScrollSnapValue;\n\t\tcachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;\n\t\tsecondaryScroller = existingResult.secondaryScroller;\n\t\tsecondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;\n\t\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n\t\texistingResult.release();\n\t} else {\n\t\tcachedScrollSnapValue = scroller.style.scrollSnapType === \"\" ? null : scroller.style.scrollSnapType;\n\t\tcachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);\n\t\tsecondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? (document.body as ScrollSnappable) : undefined;\n\t\tsecondaryScrollerCachedScrollSnapValue =\n\t\t\tsecondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === \"\" ? null : secondaryScroller.style.scrollSnapType;\n\t\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue =\n\t\t\tsecondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);\n\n\t\tconst cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue(\"scroll-snap-type\");\n\t\tconst secondaryScrollerCachedComputedScrollSnapValue =\n\t\t\tsecondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue(\"scroll-snap-type\");\n\n\t\t// If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.\n\t\tif (cachedComputedScrollSnapValue === \"none\" && secondaryScrollerCachedComputedScrollSnapValue === \"none\") {\n\t\t\treturn NOOP;\n\t\t}\n\t}\n\n\tscroller.style.scrollSnapType = \"none\";\n\tif (secondaryScroller !== undefined) {\n\t\tsecondaryScroller.style.scrollSnapType = \"none\";\n\t}\n\tif (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\tappendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n\t}\n\n\tif (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\tappendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n\t}\n\n\tlet hasReleased = false;\n\n\tconst eventTarget = scroller === scrollingElement ? window : scroller;\n\n\tfunction release() {\n\t\teventTarget.removeEventListener(\"scroll\", resetHandler);\n\t\tif (map != null) {\n\t\t\tmap.delete(scroller);\n\t\t}\n\t\thasReleased = true;\n\t}\n\n\tfunction resetHandler() {\n\t\tscroller.style.scrollSnapType = cachedScrollSnapValue;\n\n\t\tif (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {\n\t\t\tsecondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;\n\t\t}\n\n\t\tif (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\t\tappendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n\t\t}\n\n\t\tif (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\t\tappendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n\t\t}\n\n\t\trelease();\n\t}\n\n\tfunction reset() {\n\t\tsetTimeout(() => {\n\t\t\tif (hasReleased) return;\n\t\t\teventTarget.addEventListener(\"scroll\", resetHandler);\n\t\t});\n\t}\n\n\tmap.set(scroller, {\n\t\trelease,\n\t\tcachedScrollSnapValue,\n\t\tcachedScrollBehaviorStyleAttributeValue,\n\t\tsecondaryScroller,\n\t\tsecondaryScrollerCachedScrollSnapValue,\n\t\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue\n\t});\n\n\treturn {\n\t\treset\n\t};\n}\n","import {ISmoothScrollOptions} from \"../smooth-scroll-options/i-smooth-scroll-options\";\nimport {ease} from \"../../util/easing\";\nimport {disableScrollSnap, DisableScrollSnapResult} from \"../../util/disable-scroll-snap\";\n\n/**\n * The duration of a smooth scroll\n * @type {number}\n */\nconst SCROLL_TIME = 15000;\n\n/**\n * Performs a smooth repositioning of the scroll\n * @param {ISmoothScrollOptions} options\n */\nexport function smoothScroll(options: ISmoothScrollOptions): void {\n\tconst {startTime, startX, startY, endX, endY, method, scroller} = options;\n\n\tlet timeLapsed = 0;\n\tlet start: number | undefined;\n\n\tconst distanceX = endX - startX;\n\tconst distanceY = endY - startY;\n\tconst speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));\n\n\t// Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill\n\tlet scrollSnapFix: DisableScrollSnapResult | undefined = disableScrollSnap(scroller);\n\n\trequestAnimationFrame(function animate(timestamp: number) {\n\t\tif (start == null) {\n\t\t\tstart = timestamp;\n\t\t}\n\t\ttimeLapsed += timestamp - startTime;\n\t\tconst percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));\n\t\tconst positionX = Math.floor(startX + distanceX * ease(percentage));\n\t\tconst positionY = Math.floor(startY + distanceY * ease(percentage));\n\n\t\tmethod(positionX, positionY);\n\n\t\tif (positionX !== endX || positionY !== endY) {\n\t\t\trequestAnimationFrame(animate);\n\t\t\tstart = timestamp;\n\t\t} else {\n\t\t\tif (scrollSnapFix != null) {\n\t\t\t\tscrollSnapFix.reset();\n\t\t\t\tscrollSnapFix = undefined;\n\t\t\t}\n\t\t}\n\t});\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;\n","import {ScrollMethodName} from \"./scroll-method-name\";\nimport {ELEMENT_ORIGINAL_SCROLL} from \"../original/element/scroll\";\nimport {WINDOW_ORIGINAL_SCROLL} from \"../original/window/scroll\";\nimport {ELEMENT_ORIGINAL_SCROLL_BY} from \"../original/element/scroll-by\";\nimport {WINDOW_ORIGINAL_SCROLL_BY} from \"../original/window/scroll-by\";\nimport {ELEMENT_ORIGINAL_SCROLL_TO} from \"../original/element/scroll-to\";\nimport {WINDOW_ORIGINAL_SCROLL_TO} from \"../original/window/scroll-to\";\nimport {IAdjustableElement} from \"../adjustable-element/i-adjustable-element\";\n\n/**\n * A fallback if Element.prototype.scroll is not defined\n * @param {number} x\n * @param {number} y\n */\nfunction elementPrototypeScrollFallback(this: IAdjustableElement, x: number, y: number): void {\n\tthis.__adjustingScrollPosition = true;\n\tthis.scrollLeft = x;\n\tthis.scrollTop = y;\n\tdelete this.__adjustingScrollPosition;\n}\n\n/**\n * A fallback if Element.prototype.scrollTo is not defined\n * @param {number} x\n * @param {number} y\n */\nfunction elementPrototypeScrollToFallback(this: IAdjustableElement, x: number, y: number): void {\n\treturn elementPrototypeScrollFallback.call(this, x, y);\n}\n\n/**\n * A fallback if Element.prototype.scrollBy is not defined\n * @param {number} x\n * @param {number} y\n */\nfunction elementPrototypeScrollByFallback(this: IAdjustableElement, x: number, y: number): void {\n\tthis.__adjustingScrollPosition = true;\n\tthis.scrollLeft += x;\n\tthis.scrollTop += y;\n\tdelete this.__adjustingScrollPosition;\n}\n\n/**\n * Gets the original non-patched prototype method for the given kind\n * @param {ScrollMethodName} kind\n * @param {Element|Window} element\n * @return {Function}\n */\nexport function getOriginalScrollMethodForKind(kind: ScrollMethodName, element: Element | Window): Function {\n\tswitch (kind) {\n\t\tcase \"scroll\":\n\t\t\tif (element instanceof Element) {\n\t\t\t\tif (ELEMENT_ORIGINAL_SCROLL != null) {\n\t\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL;\n\t\t\t\t} else {\n\t\t\t\t\treturn elementPrototypeScrollFallback;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn WINDOW_ORIGINAL_SCROLL!;\n\t\t\t}\n\n\t\tcase \"scrollBy\":\n\t\t\tif (element instanceof Element) {\n\t\t\t\tif (ELEMENT_ORIGINAL_SCROLL_BY != null) {\n\t\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_BY;\n\t\t\t\t} else {\n\t\t\t\t\treturn elementPrototypeScrollByFallback;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn WINDOW_ORIGINAL_SCROLL_BY!;\n\t\t\t}\n\n\t\tcase \"scrollTo\":\n\t\t\tif (element instanceof Element) {\n\t\t\t\tif (ELEMENT_ORIGINAL_SCROLL_TO != null) {\n\t\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_TO;\n\t\t\t\t} else {\n\t\t\t\t\treturn elementPrototypeScrollToFallback;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn WINDOW_ORIGINAL_SCROLL_TO!;\n\t\t\t}\n\t}\n}\n","import {ISmoothScrollOptions} from \"../smooth-scroll-options/i-smooth-scroll-options\";\nimport {now} from \"../../util/now\";\nimport {ScrollMethodName} from \"../../scroll-method/scroll-method-name\";\nimport {getOriginalScrollMethodForKind} from \"../../scroll-method/get-original-scroll-method-for-kind\";\nimport {getScrollingElement} from \"../../util/scrolling-element\";\nimport {ScrollSnappable} from \"../../util/scroll-snappable\";\n\n/**\n * Gets the Smooth Scroll Options to use for the step function\n * @param {Element|Window} element\n * @param {number} x\n * @param {number} y\n * @param {ScrollMethodName} kind\n * @returns {ISmoothScrollOptions}\n */\nexport function getSmoothScrollOptions(element: Element | Window, x: number, y: number, kind: ScrollMethodName): ISmoothScrollOptions {\n\tconst startTime = now();\n\n\tif (!(element instanceof Element)) {\n\t\t// Use window as the scroll container\n\t\tconst {scrollX, pageXOffset, scrollY, pageYOffset} = window;\n\t\tconst startX = scrollX == null || scrollX === 0 ? pageXOffset : scrollX;\n\t\tconst startY = scrollY == null || scrollY === 0 ? pageYOffset : scrollY;\n\t\treturn {\n\t\t\tstartTime,\n\t\t\tstartX,\n\t\t\tstartY,\n\t\t\tendX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n\t\t\tendY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n\t\t\tmethod: getOriginalScrollMethodForKind(\"scrollTo\", window).bind(window),\n\t\t\tscroller: getScrollingElement() as ScrollSnappable\n\t\t};\n\t} else {\n\t\tconst {scrollLeft, scrollTop} = element;\n\t\tconst startX = scrollLeft;\n\t\tconst startY = scrollTop;\n\t\treturn {\n\t\t\tstartTime,\n\t\t\tstartX,\n\t\t\tstartY,\n\t\t\tendX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n\t\t\tendY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n\t\t\tmethod: getOriginalScrollMethodForKind(\"scrollTo\", element).bind(element),\n\t\t\tscroller: element as ScrollSnappable\n\t\t};\n\t}\n}\n","/**\n * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()\n * @returns {number}\n */\nexport function now(): number {\n\tif (\"performance\" in window) return performance.now();\n\treturn Date.now();\n}\n","/**\n * Ensures that the given value is numeric\n * @param {number} value\n * @return {number}\n */\nexport function ensureNumeric(value: unknown): number {\n\tif (value == null) return 0;\n\telse if (typeof value === \"number\") {\n\t\treturn value;\n\t} else if (typeof value === \"string\") {\n\t\treturn parseFloat(value);\n\t} else {\n\t\treturn 0;\n\t}\n}\n","/**\n * Returns true if the given value is some ScrollToOptions\n * @param {number | ScrollToOptions} value\n * @return {value is ScrollToOptions}\n */\nexport function isScrollToOptions(value: number | ScrollToOptions | undefined): value is ScrollToOptions {\n\treturn value != null && typeof value === \"object\";\n}\n","import {getScrollBehavior} from \"../util/get-scroll-behavior\";\nimport {smoothScroll} from \"../smooth-scroll/smooth-scroll/smooth-scroll\";\nimport {getSmoothScrollOptions} from \"../smooth-scroll/get-smooth-scroll-options/get-smooth-scroll-options\";\nimport {ensureNumeric} from \"../util/ensure-numeric\";\nimport {isScrollToOptions} from \"../util/is-scroll-to-options\";\nimport {ScrollMethodName} from \"../scroll-method/scroll-method-name\";\nimport {getOriginalScrollMethodForKind} from \"../scroll-method/get-original-scroll-method-for-kind\";\n\n/**\n * Handles a scroll method\n * @param {Element|Window} element\n * @param {ScrollMethodName} kind\n * @param {number | ScrollToOptions} optionsOrX\n * @param {number} y\n */\nexport function handleScrollMethod(element: Element | Window, kind: ScrollMethodName, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\tonScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);\n}\n\n/**\n * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument\n * @param {ScrollToOptions} options\n * @param {Element|Window} element\n * @param {ScrollMethodName} kind\n */\nfunction onScrollWithOptions(options: Required<ScrollToOptions>, element: Element | Window, kind: ScrollMethodName): void {\n\tconst behavior = getScrollBehavior(element, options);\n\n\t// If the behavior is 'auto' apply instantaneous scrolling\n\tif (behavior == null || behavior === \"auto\") {\n\t\tgetOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);\n\t} else {\n\t\tsmoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));\n\t}\n}\n\n/**\n * Normalizes the given scroll coordinates\n * @param {number?} x\n * @param {number?} y\n * @return {Required<Pick<ScrollToOptions, \"top\" | \"left\">>}\n */\nfunction normalizeScrollCoordinates(x: number | undefined, y: number | undefined): Required<Pick<ScrollToOptions, \"top\" | \"left\">> {\n\treturn {\n\t\tleft: ensureNumeric(x),\n\t\ttop: ensureNumeric(y)\n\t};\n}\n\n/**\n * Gets ScrollToOptions based on the given arguments. Will throw if validation fails\n * @param {number | ScrollToOptions} optionsOrX\n * @param {number} y\n * @return {Required<ScrollToOptions>}\n */\nfunction getScrollToOptionsWithValidation(optionsOrX?: number | ScrollToOptions, y?: number): Required<ScrollToOptions> {\n\t// If only one argument is given, and it isn't an options object, throw a TypeError\n\tif (y === undefined && !isScrollToOptions(optionsOrX)) {\n\t\tthrow new TypeError(\"Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.\");\n\t}\n\n\t// Scroll based on the primitive values given as arguments\n\tif (!isScrollToOptions(optionsOrX)) {\n\t\treturn {\n\t\t\t...normalizeScrollCoordinates(optionsOrX, y),\n\t\t\tbehavior: \"auto\"\n\t\t};\n\t}\n\n\t// Scroll based on the received options object\n\telse {\n\t\treturn {\n\t\t\t...normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top),\n\t\t\tbehavior: optionsOrX.behavior == null ? \"auto\" : optionsOrX.behavior\n\t\t};\n\t}\n}\n","// tslint:disable:no-any\n\n/**\n * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)\n * @param {EventTarget} currentElement\n * @returns {EventTarget | null}\n */\nexport function getParent(currentElement: EventTarget): Element | Window | Node | null {\n\tif (\"nodeType\" in currentElement && (<Node>currentElement).nodeType === 1) {\n\t\treturn (<Node>currentElement).parentNode;\n\t}\n\n\tif (\"ShadowRoot\" in window && currentElement instanceof (<any>window).ShadowRoot) {\n\t\treturn (<ShadowRoot>currentElement).host;\n\t} else if (currentElement === document) {\n\t\treturn window;\n\t} else if (currentElement instanceof Node) return currentElement.parentNode;\n\n\treturn null;\n}\n","import {getParent} from \"./get-parent\";\nimport {getScrollBehavior} from \"./get-scroll-behavior\";\nimport {getScrollingElement} from \"./scrolling-element\";\n\n/**\n * Returns true if the given overflow property represents a scrollable overflow value\n * @param {string | null} overflow\n * @return {boolean}\n */\nfunction canOverflow(overflow: string | null): boolean {\n\treturn overflow !== \"visible\" && overflow !== \"clip\";\n}\n\n/**\n * Returns true if the given element is scrollable\n * @param {Element} element\n * @return {boolean}\n */\nfunction isScrollable(element: Element) {\n\tif (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n\t\tconst style = getComputedStyle(element, null);\n\t\treturn canOverflow(style.overflowY) || canOverflow(style.overflowX);\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds the nearest ancestor of an element that can scroll\n * @param {Element} target\n * @returns {Element|Window?}\n */\nexport function findNearestAncestorsWithScrollBehavior(target: Element | HTMLElement): [Element | HTMLElement, ScrollBehavior] {\n\tlet currentElement: Element | HTMLElement = target;\n\tconst scrollingElement = getScrollingElement();\n\n\twhile (currentElement != null) {\n\t\tconst behavior = getScrollBehavior(currentElement);\n\t\tif (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {\n\t\t\treturn [currentElement, behavior];\n\t\t}\n\n\t\tconst parent = getParent(currentElement);\n\t\tcurrentElement = parent as Element;\n\t}\n\n\t// No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll\n\tcurrentElement = target;\n\n\twhile (currentElement != null) {\n\t\tif (currentElement === scrollingElement || isScrollable(currentElement)) {\n\t\t\treturn [currentElement, \"auto\"];\n\t\t}\n\n\t\tconst parent = getParent(currentElement);\n\t\tcurrentElement = parent as Element;\n\t}\n\n\t// Default to the scrolling element\n\treturn [scrollingElement, \"auto\"];\n}\n","/**\n * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)\n * @returns {string}\n */\nexport function getLocationOrigin(locationLike: Location | HTMLAnchorElement = location): string {\n\tif (\"origin\" in locationLike && locationLike.origin != null) {\n\t\treturn locationLike.origin;\n\t}\n\n\tlet port = locationLike.port != null && locationLike.port.length > 0 ? `:${locationLike.port}` : \"\";\n\n\tif (locationLike.protocol === \"http:\" && port === \":80\") {\n\t\tport = \"\";\n\t} else if (locationLike.protocol === \"https:\" && port === \":443\") {\n\t\tport = \"\";\n\t}\n\n\treturn `${locationLike.protocol}//${locationLike.hostname}${port}`;\n}\n","import {findNearestAncestorsWithScrollBehavior} from \"../../util/find-nearest-ancestor-with-scroll-behavior\";\nimport {findNearestRoot} from \"../../util/find-nearest-root\";\nimport {getLocationOrigin} from \"../../util/get-location-origin\";\n\n/**\n * A Regular expression that matches id's of the form \"#[digit]\"\n * @type {RegExp}\n */\nconst ID_WITH_LEADING_DIGIT_REGEXP = /^#\\d/;\n\n/**\n * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled\n * if the scroll behavior is smooth in the first rooter within that context\n */\nexport function catchNavigation(): void {\n\t// Listen for 'click' events globally\n\twindow.addEventListener(\"click\", e => {\n\t\t// Only work with trusted events on HTMLAnchorElements\n\t\tif (!e.isTrusted || !(e.target instanceof HTMLAnchorElement)) return;\n\n\t\tconst {pathname, search, hash} = e.target;\n\t\tconst pointsToCurrentPage =\n\t\t\tgetLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;\n\n\t\t// Only work with HTMLAnchorElements that navigates to a specific ID on the current page\n\t\tif (!pointsToCurrentPage || hash == null || hash.length < 1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find the nearest root, whether it be a ShadowRoot or the document itself\n\t\tconst root = findNearestRoot(e.target);\n\n\t\t// Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation\n\t\tconst elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);\n\n\t\t// If no selector could be found, don't proceed\n\t\tif (elementMatch == null) return;\n\n\t\t// Find the nearest ancestor that can be scrolled\n\t\tconst [, behavior] = findNearestAncestorsWithScrollBehavior(elementMatch);\n\n\t\t// If the behavior isn't smooth, don't proceed\n\t\tif (behavior !== \"smooth\") return;\n\n\t\t// Otherwise, first prevent the default action.\n\t\te.preventDefault();\n\n\t\t// Now, scroll to the element with that ID\n\t\telementMatch.scrollIntoView({\n\t\t\tbehavior\n\t\t});\n\t});\n}\n","import {getParent} from \"./get-parent\";\n\n// tslint:disable:no-any\n\n/**\n * Finds the nearest root from an element\n * @param {Element} target\n * @returns {Document|ShadowRoot}\n */\nexport function findNearestRoot(target: Element): Document | ShadowRoot {\n\tlet currentElement: EventTarget | null = target;\n\twhile (currentElement != null) {\n\t\tif (\"ShadowRoot\" in window && currentElement instanceof (window as any).ShadowRoot) {\n\t\t\t// Assume this is a ShadowRoot\n\t\t\treturn currentElement as ShadowRoot;\n\t\t}\n\n\t\tconst parent = getParent(currentElement);\n\n\t\tif (parent === currentElement) {\n\t\t\treturn document;\n\t\t}\n\n\t\tcurrentElement = parent;\n\t}\n\treturn document;\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;\n","/**\n * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),\n * but has been rewritten to accept a scroller as an argument.\n */\nimport {getScrollingElement} from \"../../util/scrolling-element\";\n\n// tslint:disable\n\ninterface IVisualViewport {\n\theight: number;\n\twidth: number;\n}\n\ndeclare var visualViewport: IVisualViewport;\n\ninterface VisualViewportable {\n\tvisualViewport?: {\n\t\theight: number;\n\t\twidth: number;\n\t};\n}\n\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarly to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nfunction alignNearest(\n\tscrollingEdgeStart: number,\n\tscrollingEdgeEnd: number,\n\tscrollingSize: number,\n\tscrollingBorderStart: number,\n\tscrollingBorderEnd: number,\n\telementEdgeStart: number,\n\telementEdgeEnd: number,\n\telementSize: number\n) {\n\t/**\n\t * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n\t *\n\t *          ┌──┐\n\t *        ┏━│━━│━┓\n\t *          │  │\n\t *        ┃ │  │ ┃        do nothing\n\t *          │  │\n\t *        ┗━│━━│━┛\n\t *          └──┘\n\t *\n\t *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n\t *\n\t *    ┏ ━ ━ ━ ━ ┓\n\t *   ┌───────────┐\n\t *   │┃         ┃│        do nothing\n\t *   └───────────┘\n\t *    ┗ ━ ━ ━ ━ ┛\n\t */\n\tif (\n\t\t(elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n\t\t(elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n\t) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n\t *\n\t *          ┌──┐\n\t *        ┏━│━━│━┓         ┏━┌━━┐━┓\n\t *          └──┘             │  │\n\t *  from  ┃      ┃     to  ┃ └──┘ ┃\n\t *\n\t *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n\t *\n\t * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n\t *\n\t *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n\t *                           │  │\n\t *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n\t *          │  │             │  │\n\t *        ┗━│━━│━┛         ┗━│━━│━┛\n\t *          │  │             └──┘\n\t *          │  │\n\t *          └──┘\n\t *\n\t * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n\t *\n\t *       from                 to\n\t *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n\t *  ┌───┐                 ┌───┐\n\t *  │ ┃ │       ┃         ┃   │     ┃\n\t *  └───┘                 └───┘\n\t *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n\t *\n\t * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n\t *\n\t *       from                 to\n\t *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n\t *        ┌───────────┐   ┌───────────┐\n\t *    ┃   │     ┃     │   ┃         ┃ │\n\t *        └───────────┘   └───────────┘\n\t *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n\t */\n\tif (\n\t\t(elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n\t\t(elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n\t) {\n\t\treturn elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n\t}\n\n\t/**\n\t * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n\t *\n\t *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n\t *\n\t *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n\t *          ┌──┐             │  │\n\t *        ┗━│━━│━┛         ┗━└━━┘━┛\n\t *          └──┘\n\t *\n\t * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n\t *\n\t *          ┌──┐\n\t *          │  │\n\t *          │  │             ┌──┐\n\t *        ┏━│━━│━┓         ┏━│━━│━┓\n\t *          │  │             │  │\n\t *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n\t *                           │  │\n\t *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n\t *\n\t * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n\t *\n\t *           from                 to\n\t *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n\t *  ┌───────────┐           ┌───────────┐\n\t *  │     ┃     │   ┃       │ ┃         ┃\n\t *  └───────────┘           └───────────┘\n\t *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n\t *\n\t * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n\t *\n\t *           from                 to\n\t *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n\t *                ┌───┐             ┌───┐\n\t *        ┃       │ ┃ │       ┃     │   ┃\n\t *                └───┘             └───┘\n\t *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n\t *\n\t */\n\tif ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n\t\treturn elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n\t}\n\n\treturn 0;\n}\n\nexport function computeScrollIntoView(target: Element, scroller: Element, options: ScrollIntoViewOptions): Pick<ScrollToOptions, \"top\" | \"left\"> {\n\tconst {block, inline} = options;\n\n\t// Used to handle the top most element that can be scrolled\n\tconst scrollingElement = getScrollingElement();\n\n\t// Support pinch-zooming properly, making sure elements scroll into the visual viewport\n\t// Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n\t// and viewport dimensions on window.innerWidth/Height\n\t// https://www.quirksmode.org/mobile/viewports2.html\n\t// https://bokand.github.io/viewport/index.html\n\tconst viewportWidth = (window as VisualViewportable).visualViewport != null ? visualViewport.width : innerWidth;\n\tconst viewportHeight = (window as VisualViewportable).visualViewport != null ? visualViewport.height : innerHeight;\n\n\tconst viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;\n\tconst viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;\n\n\tconst {\n\t\theight: targetHeight,\n\t\twidth: targetWidth,\n\t\ttop: targetTop,\n\t\tright: targetRight,\n\t\tbottom: targetBottom,\n\t\tleft: targetLeft\n\t} = target.getBoundingClientRect();\n\n\t// These values mutate as we loop through and generate scroll coordinates\n\tconst targetBlock: number = block === \"start\" || block === \"nearest\" ? targetTop : block === \"end\" ? targetBottom : targetTop + targetHeight / 2; // block === 'center\n\tconst targetInline: number = inline === \"center\" ? targetLeft + targetWidth / 2 : inline === \"end\" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest\n\n\tconst {height, width, top, right, bottom, left} = scroller.getBoundingClientRect();\n\n\tconst frameStyle = getComputedStyle(scroller);\n\tconst borderLeft = parseInt(frameStyle.borderLeftWidth as string, 10);\n\tconst borderTop = parseInt(frameStyle.borderTopWidth as string, 10);\n\tconst borderRight = parseInt(frameStyle.borderRightWidth as string, 10);\n\tconst borderBottom = parseInt(frameStyle.borderBottomWidth as string, 10);\n\n\tlet blockScroll: number = 0;\n\tlet inlineScroll: number = 0;\n\n\t// The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n\t// @TODO find out if the \"as HTMLElement\" overrides can be dropped\n\tconst scrollbarWidth =\n\t\t\"offsetWidth\" in scroller ? (scroller as HTMLElement).offsetWidth - (scroller as HTMLElement).clientWidth - borderLeft - borderRight : 0;\n\tconst scrollbarHeight =\n\t\t\"offsetHeight\" in scroller ? (scroller as HTMLElement).offsetHeight - (scroller as HTMLElement).clientHeight - borderTop - borderBottom : 0;\n\n\tif (scrollingElement === scroller) {\n\t\t// Handle viewport logic (document.documentElement or document.body)\n\n\t\tif (block === \"start\") {\n\t\t\tblockScroll = targetBlock;\n\t\t} else if (block === \"end\") {\n\t\t\tblockScroll = targetBlock - viewportHeight;\n\t\t} else if (block === \"nearest\") {\n\t\t\tblockScroll = alignNearest(\n\t\t\t\tviewportY,\n\t\t\t\tviewportY + viewportHeight,\n\t\t\t\tviewportHeight,\n\t\t\t\tborderTop,\n\t\t\t\tborderBottom,\n\t\t\t\tviewportY + targetBlock,\n\t\t\t\tviewportY + targetBlock + targetHeight,\n\t\t\t\ttargetHeight\n\t\t\t);\n\t\t} else {\n\t\t\t// block === 'center' is the default\n\t\t\tblockScroll = targetBlock - viewportHeight / 2;\n\t\t}\n\n\t\tif (inline === \"start\") {\n\t\t\tinlineScroll = targetInline;\n\t\t} else if (inline === \"center\") {\n\t\t\tinlineScroll = targetInline - viewportWidth / 2;\n\t\t} else if (inline === \"end\") {\n\t\t\tinlineScroll = targetInline - viewportWidth;\n\t\t} else {\n\t\t\t// inline === 'nearest' is the default\n\t\t\tinlineScroll = alignNearest(\n\t\t\t\tviewportX,\n\t\t\t\tviewportX + viewportWidth,\n\t\t\t\tviewportWidth,\n\t\t\t\tborderLeft,\n\t\t\t\tborderRight,\n\t\t\t\tviewportX + targetInline,\n\t\t\t\tviewportX + targetInline + targetWidth,\n\t\t\t\ttargetWidth\n\t\t\t);\n\t\t}\n\n\t\t// Apply scroll position offsets and ensure they are within bounds\n\t\t// @TODO add more test cases to cover this 100%\n\t\tblockScroll = Math.max(0, blockScroll + viewportY);\n\t\tinlineScroll = Math.max(0, inlineScroll + viewportX);\n\t} else {\n\t\t// Handle each scrolling frame that might exist between the target and the viewport\n\n\t\tif (block === \"start\") {\n\t\t\tblockScroll = targetBlock - top - borderTop;\n\t\t} else if (block === \"end\") {\n\t\t\tblockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n\t\t} else if (block === \"nearest\") {\n\t\t\tblockScroll = alignNearest(\n\t\t\t\ttop,\n\t\t\t\tbottom,\n\t\t\t\theight,\n\t\t\t\tborderTop,\n\t\t\t\tborderBottom + scrollbarHeight,\n\t\t\t\ttargetBlock,\n\t\t\t\ttargetBlock + targetHeight,\n\t\t\t\ttargetHeight\n\t\t\t);\n\t\t} else {\n\t\t\t// block === 'center' is the default\n\t\t\tblockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;\n\t\t}\n\n\t\tif (inline === \"start\") {\n\t\t\tinlineScroll = targetInline - left - borderLeft;\n\t\t} else if (inline === \"center\") {\n\t\t\tinlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;\n\t\t} else if (inline === \"end\") {\n\t\t\tinlineScroll = targetInline - right + borderRight + scrollbarWidth;\n\t\t} else {\n\t\t\t// inline === 'nearest' is the default\n\t\t\tinlineScroll = alignNearest(\n\t\t\t\tleft,\n\t\t\t\tright,\n\t\t\t\twidth,\n\t\t\t\tborderLeft,\n\t\t\t\tborderRight + scrollbarWidth,\n\t\t\t\ttargetInline,\n\t\t\t\ttargetInline + targetWidth,\n\t\t\t\ttargetWidth\n\t\t\t);\n\t\t}\n\n\t\tconst {scrollLeft, scrollTop} = scroller;\n\t\t// Ensure scroll coordinates are not out of bounds while applying scroll offsets\n\t\tblockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));\n\t\tinlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));\n\t}\n\n\treturn {\n\t\ttop: blockScroll,\n\t\tleft: inlineScroll\n\t};\n}\n","import {findNearestAncestorsWithScrollBehavior} from \"../../util/find-nearest-ancestor-with-scroll-behavior\";\nimport {ELEMENT_ORIGINAL_SCROLL_INTO_VIEW} from \"../../original/element/scroll-into-view\";\nimport {computeScrollIntoView} from \"./compute-scroll-into-view\";\nimport {getOriginalScrollMethodForKind} from \"../../scroll-method/get-original-scroll-method-for-kind\";\n\n/**\n * Patches the 'scrollIntoView' method on the Element prototype\n */\nexport function patchElementScrollIntoView(): void {\n\tElement.prototype.scrollIntoView = function(this: Element, arg?: boolean | ScrollIntoViewOptions): void {\n\t\tconst normalizedOptions: ScrollIntoViewOptions =\n\t\t\targ == null || arg === true\n\t\t\t\t? {\n\t\t\t\t\t\tblock: \"start\",\n\t\t\t\t\t\tinline: \"nearest\"\n\t\t\t\t  }\n\t\t\t\t: arg === false\n\t\t\t\t? {\n\t\t\t\t\t\tblock: \"end\",\n\t\t\t\t\t\tinline: \"nearest\"\n\t\t\t\t  }\n\t\t\t\t: arg;\n\n\t\t// Find the nearest ancestor that can be scrolled\n\t\tconst [ancestorWithScroll, ancestorWithScrollBehavior] = findNearestAncestorsWithScrollBehavior(this);\n\n\t\tconst behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;\n\n\t\t// If the behavior isn't smooth, simply invoke the original implementation and do no more\n\t\tif (behavior !== \"smooth\") {\n\t\t\t// Assert that 'scrollIntoView' is actually defined\n\t\t\tif (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {\n\t\t\t\tELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);\n\t\t\t}\n\n\t\t\t// Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates\n\t\t\telse {\n\t\t\t\tconst {top, left} = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions);\n\t\t\t\tgetOriginalScrollMethodForKind(\"scrollTo\", this).call(this, left, top);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tancestorWithScroll.scrollTo({\n\t\t\tbehavior,\n\t\t\t...computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)\n\t\t});\n\t};\n\n\t// On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.\n\tif (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {\n\t\tHTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;\n\t}\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n\t? undefined\n\t: Object.getOwnPropertyDescriptor(Element.prototype, \"scrollTop\")!.set!;\n","import {handleScrollMethod} from \"../shared\";\nimport {ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR} from \"../../original/element/scroll-top\";\n\n/**\n * Patches the 'scrollTop' property descriptor on the Element prototype\n */\nexport function patchElementScrollTop(): void {\n\tObject.defineProperty(Element.prototype, \"scrollTop\", {\n\t\tset(scrollTop: number) {\n\t\t\tif (this.__adjustingScrollPosition) {\n\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR!.call(this, scrollTop);\n\t\t\t}\n\n\t\t\thandleScrollMethod(this, \"scrollTo\", this.scrollLeft, scrollTop);\n\t\t\treturn scrollTop;\n\t\t}\n\t});\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n\t? undefined\n\t: Object.getOwnPropertyDescriptor(Element.prototype, \"scrollLeft\")!.set!;\n","import {UNSUPPORTED_ENVIRONMENT} from \"./unsupported-environment\";\n\n/**\n * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods\n * @type {boolean}\n */\nexport const SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT\n\t? false\n\t: \"scroll\" in Element.prototype && \"scrollTo\" in Element.prototype && \"scrollBy\" in Element.prototype && \"scrollIntoView\" in Element.prototype;\n","import {SUPPORTS_SCROLL_BEHAVIOR} from \"./support/supports-scroll-behavior\";\nimport {patch} from \"./patch/patch\";\nimport {SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS} from \"./support/supports-element-prototype-scroll-methods\";\nimport {UNSUPPORTED_ENVIRONMENT} from \"./support/unsupported-environment\";\n\nif (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {\n\tpatch();\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scroll' method on the Element prototype\n */\nexport function patchElementScroll(): void {\n\tElement.prototype.scroll = function(this: Element, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scroll\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollBy' method on the Element prototype\n */\nexport function patchElementScrollBy(): void {\n\tElement.prototype.scrollBy = function(this: Element, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollTo' method on the Element prototype\n */\nexport function patchElementScrollTo(): void {\n\tElement.prototype.scrollTo = function(this: Element, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\nimport {ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR} from \"../../original/element/scroll-left\";\n\n/**\n * Patches the 'scrollLeft' property descriptor on the Element prototype\n */\nexport function patchElementScrollLeft(): void {\n\tObject.defineProperty(Element.prototype, \"scrollLeft\", {\n\t\tset(scrollLeft: number) {\n\t\t\tif (this.__adjustingScrollPosition) {\n\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR!.call(this, scrollLeft);\n\t\t\t}\n\n\t\t\thandleScrollMethod(this, \"scrollTo\", scrollLeft, this.scrollTop);\n\t\t\treturn scrollLeft;\n\t\t}\n\t});\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scroll' method on the Window prototype\n */\nexport function patchWindowScroll(): void {\n\twindow.scroll = function(this: Window, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scroll\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollBy' method on the Window prototype\n */\nexport function patchWindowScrollBy(): void {\n\twindow.scrollBy = function(this: Window, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollTo' method on the Window prototype\n */\nexport function patchWindowScrollTo(): void {\n\twindow.scrollTo = function(this: Window, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n\t};\n}\n","import {patchElementScroll} from \"./element/scroll\";\nimport {patchElementScrollBy} from \"./element/scroll-by\";\nimport {patchElementScrollTo} from \"./element/scroll-to\";\nimport {patchWindowScroll} from \"./window/scroll\";\nimport {patchWindowScrollBy} from \"./window/scroll-by\";\nimport {patchWindowScrollTo} from \"./window/scroll-to\";\nimport {catchNavigation} from \"./anchor/catch-navigation\";\nimport {patchElementScrollIntoView} from \"./element/scroll-into-view\";\nimport {patchElementScrollTop} from \"./element/scroll-top\";\nimport {patchElementScrollLeft} from \"./element/scroll-left\";\n\n/**\n * Applies the polyfill\n */\nexport function patch(): void {\n\t// Element.prototype methods\n\tpatchElementScroll();\n\tpatchElementScrollBy();\n\tpatchElementScrollTo();\n\tpatchElementScrollIntoView();\n\n\t// Element.prototype descriptors\n\tpatchElementScrollLeft();\n\tpatchElementScrollTop();\n\n\t// window methods\n\tpatchWindowScroll();\n\tpatchWindowScrollBy();\n\tpatchWindowScrollTo();\n\n\t// Navigation\n\tcatchNavigation();\n}\n"],"sourceRoot":""}